# Nome do workflow, que aparecerá na aba "Actions" do GitHub
name: Flutter CI - Lint, Format & Test

# Define os gatilhos que disparam o workflow
on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

# Define os jobs a serem executados
jobs:
  build_and_test:
    # Máquina virtual onde o job será executado
    runs-on: ubuntu-latest

    # Sequência de passos que o job executa
    steps:
      # 1. Clona o seu repositório para a máquina virtual
      - name: Checkout do código
        uses: actions/checkout@v4

      # 2. Configura o cache para o SDK do Flutter
      # Isso evita baixar o Flutter em todas as execuções
      - name: Cache do Flutter
        uses: actions/cache@v4
        with:
          path: /opt/hostedtoolcache/flutter
          key: ${{ runner.os }}-flutter-${{ hashFiles('**/pubspec.lock') }}
          restore-keys: |
            ${{ runner.os }}-flutter-

      # 3. Configura o ambiente Flutter SDK
      # A action é inteligente e usará o cache se disponível
      - name: Configurar Flutter SDK
        uses: subosito/flutter-action@v2
        with:
          channel: 'stable'

      # 4. Instala todas as dependências do projeto
      - name: Instalar dependências
        run: flutter pub get

      # 5. Verifica a formatação do código. O comando correto é "dart format".
      - name: Verificar formatação
        run: dart format --output=none --set-exit-if-changed .

      # 6. Roda o linter e o analisador estático
      - name: Analisar e rodar o Linter
        run: flutter analyze --fatal-infos

      # 7. Roda a suíte de testes do projeto
      - name: Rodar os testes
        run: flutter test
