# Nome do workflow, que aparecerá na aba "Actions" do GitHub
name: Flutter CI - Lint, Format & Test

# Define os gatilhos que disparam o workflow
on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

# Define os jobs a serem executados
jobs:
  build_and_test:
    # Máquina virtual onde o job será executado
    runs-on: ubuntu-latest

    # Sequência de passos que o job executa
    steps:
      # 1. Clona o seu repositório para a máquina virtual
      - name: Checkout do código
        uses: actions/checkout@v4

      # 2. Configura o cache para o SDK do Flutter
      # Isso evita baixar o Flutter em todas as execuções
      - name: Cache flutter
        uses: subosito/flutter-action@v2
        with:
          channel: stable
          cache: true
          # optional parameters follow
          cache-key: "flutter-:os:-:channel:-:version:-:arch:-:hash:" # optional, change this to force refresh cache
          cache-path: "${{ runner.tool_cache }}/flutter/:channel:-:version:-:arch:" # optional, change this to specify the cache path
          pub-cache-key: "flutter-pub-:os:-:channel:-:version:-:arch:-:hash:" # optional, change this to force refresh cache of dart pub get dependencies
          pub-cache-path: "${{ runner.tool_cache }}/flutter/:channel:-:version:-:arch:" # optional, change this to specify the cache path
      - run: flutter --version

      # 3. Configura o ambiente Flutter SDK
      # A action é inteligente e usará o cache se disponível
      - name: Configurar Flutter SDK
        uses: subosito/flutter-action@v2
        with:
          channel: 'stable'

      # 4. Instala todas as dependências do projeto
      - name: Instalar dependências
        run: flutter pub get

      # 6. Roda o linter e o analisador estático
      - name: Analisar e rodar o Linter
        run: flutter analyze --fatal-infos

      # # 7. Roda a suíte de testes do projeto
      # - name: Rodar os testes
      #   run: flutter test
